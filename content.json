[{"title":"equals 和 == 的区别","date":"2017-09-14T15:41:34.000Z","path":"2017/09/14/equals-和-的区别/","text":"1.一句话== 操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。 equals操作表示的是两个变量是否是对同一个对象的引用，即堆中的内容是否相同。 更简单的说法：==比较的是地址，equals比较的是内容 2.举个栗子123456789101112public class EqualsTest &#123; public static void main(String[] args)&#123; String s1 = &quot;Test&quot;; String s2 = &quot;Test&quot;; System.out.println(&quot;s1 == s2 : &quot; + (s1 == s2)); System.out.println(&quot;s1.equals(s2): &quot; + s1.equals(s2)); &#125;&#125;输出结果：s1 == s2 : trues1.equals(s2): true 接下来，做些改动：将s2通过new的方式来创建 123456789101112public class EqualsTest &#123; public static void main(String[] args)&#123; String s1 = &quot;Test&quot;; String s2 = new String(&quot;Test&quot;); System.out.println(&quot;s1 == s2 : &quot; + (s1 == s2)); System.out.println(&quot;s1.equals(s2): &quot; + s1.equals(s2)); &#125;&#125;输出结果：s1 == s2 : falses1.equals(s2): true 分析： 对于第一种情况，创建s2时，程序会在缓冲池中寻找到具有相同值的s1，因此s2和s1共同引用对象”Test”。也就是说s1和s2的引用地址相同，那么自然引用对象也是相同的咯。所以两者都为true。 对于第二种情况，我们通过new方式创建了s2，相当于告诉程序“我要个新的，不要旧的”。因此，程序会重新创建一个”Test”对象在内存中，虽然它们的值相同，但它们的位置是不同的。因此，它们的引用地址自然是不同的，==操作自然为false，equals为true，因为它们的内容还是相同的。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"java之线程与进程","date":"2016-02-09T17:39:53.000Z","path":"2016/02/10/java之线程与进程/","text":"一.进程和线程1. 举个例子&emsp;&emsp;开个QQ，开了一个进程；开了迅雷，开了一个进程。在QQ的这个进程里，传输文字开一个线程、传输语音开了一个线程、弹出对话框又开了一个线程。所以运行某个软件，相当于开了一个进程。在这个软件运行的过程里（在这个进程里），多个工作支撑的完成QQ的运行，那么这“多个工作”分别有一个线程。所以一个进程管着多个线程。通俗的讲：“进程是爹妈，管着众多的线程儿子”。&emsp;&emsp; 二.3.4.5.6.7.8.9.10.","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"抽象类和接口","date":"2016-01-14T17:39:53.000Z","path":"2016/01/15/抽象类和接口/","text":"1.抽象类&emsp;&emsp;抽象类是用来描述抽象行为的，比如Animal，我们不知道Animal具体有会有什么样的行为，只有具体的动物类，如Dog，Cat才有具体的行为，才能够被实例化。抽象类是实现多态的一种机制，它可以包含具体方法（有具体实现的方法），也可以包含抽象方法，而继承它的子类必须实现这些方法，下面总结了一下抽象类的特性： 不能被实例化，但可以有构造函数 抽象方法必须由子类进行重写 只要包含一个抽象方法的类，就必须定义为抽象类，不管是否还包含其他方法 抽象类中可以包含具体的方法，也可以不包含抽象方法 抽象类可以包含普通成员变量，其访问类型可以任意 抽象类也可以包含静态成员变量，其访问类型可以任意 子类中的抽象方法不能与父类的抽象方法同名 abstract不能与private、static、final或native并列修饰同一个方法2.接口&emsp;&emsp;接口在Java当中是通过关键字interface来实现，接口不是类，所以也不能被实例化，接口是用来建立类与类之间的协议，它的提供的只是一种形式，而没有具体的实现。实现类实现(implements)接口，必须实现接口的全部方法&emsp;&emsp;接口是抽象类的延伸，Java不允许多重继承（即不能有多个父类，只能有一个），但可以实现多个接口。在使用接口的过程中，就注意以下几个问题： 接口中不能有构造方法。 接口的所有方法自动被声明为public，而且只能为public，如果使用protected、private，会导致编译错误。 接口可以定义”成员变量”，而且会自动转为public final static，即常量，而且必须被显式初始化。 接口中的所有方法都是抽象方法，不能包含实现的方法，也不能包含静态方法 实现接口的非抽象类必须实现接口的所有方法，而抽象类不需要 不能使用new来实现化接口，但可以声明一个接口变量，它必须引用一个实现该接口的类的对象，可以使用instanceOf来判断一个类是否实现了某个接口，如if (object instanceOf ClassName){doSth()} 3.总结从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。 抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。 在抽象类中可以拥有自己的成员变量和非抽象类方法，但是接口中只能存在静态的不可变的成员数据（不过一般都不在接口中定义成员数据），而且它的所有方法都是抽象的。 抽象类和接口所反映的设计理念是不同的，抽象类所代表的是”is-a”的关系，而接口所代表的是”like-a”的关系。抽象类和接口是java语言中两种不同的抽象概念，他们的存在对多态提供了非常好的支持，虽然他们之间存在很大的相似性。但是对于他们的选择往往反应了您对问题域的理解。只有对问题域的本质有良好的理解，才能做出正确、合理的设计。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Idea for mac  MyBatis-plugin破解","date":"2016-01-09T17:39:53.000Z","path":"2016/01/10/Idea-for-mac-MyBatis-plugin破解/","text":"1.下载MyBatis-plugin插件Preferences–&gt;Plugins–&gt;搜索Mybatis-Plugin–&gt;Install–&gt;关闭Idea 2.找到Idea中MyBatis-plugin的安装路径1cd ~/Library/Application Support/IntelliJIdea201X.X/mybatis_plus/lib 3.克隆项目1git clone https://github.com/myoss/profile.git 4.将profile里面的com拷贝到 lib下1cp -R ./profile/idea/plugin/MybatisPulgin/v2.7~2.91/com ~/Library/Application Support/IntelliJIdea201x.x/mybatis_plus/lib 5.用com文件夹中的信息更新mybatis_plus.jar1jar uvf mybatis_plus.jar com 6.重启idea","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"Java跨平台原理","date":"2016-01-08T17:39:53.000Z","path":"2016/01/09/Java跨平台原理 /","text":"1.什么是平台 &emsp;&emsp;Java是可以跨平台的编程语言，那我们首先得知道什么是平台，我们把CPU处理器与操作系统的整体叫平台。&emsp;&emsp;CPU大家都知道，如果计算机是人,那CPU就是人的大脑，它既负责思维运算，又负责身体各部件的命令控制。CPU的种类很多，除去我们熟知的Intel与AMD外，还有比如上面说到的SUN的Sparc,比如IBM的PowerPC等等，这些各个公司生产的CPU使用或相同或不同的指令集。指令集就是cpu中用来计算和控制计算机系统的一套指令的集合。指令集又分为精简指令集（RISC）与复杂指令集(CISC)，每种cpu都有其特定的指令集。开发程序，首先要知道该程序在什么CPU上运行,也就是要知道CPU所使用的指令集。&emsp;&emsp;下面说操作系统，操作系统是充当用户和计算机之间交互的界面软件，不同的操作系统支持不同的CPU，严格意义上说是不同的操作系统支持不同CPU的指令集。例如 windows和liunx都支持Intel和AMD的复杂指令集，但并不支持PowerPC所使用的精简指令集，而早期的MAC电脑使用的是PowerPC处理器，所以也就无法在MAC下直接安装windows,直到05年MAC改用了Intel的CPU,才使在MAC下安装windows成为可能。但问题来了，原来的MAC 操作系统也只支持PowerPC,在Intel上也不能安装，怎么办？所以苹果公司也得重写自己的MAC操作系统以支持这种变化。最后总结下，我们要知道，不同的操作系统支持不同的CPU指令集，现在的windows,liunx,mac,solaris都支持Intel与AMD的CPU指令集。&emsp;&emsp;有了上面的铺垫，旺旺老师就要告诉大家，如果您要开发程序，首先应该确定：1，CPU类型，也就是指令集类型；2，操作系统；我们把这种软硬件的结合叫平台。也可以说“平台= CPU+OS”。又因为现在主流的操作系统都支持主流的CPU，所以有时也把操作系统称为平台。&emsp;&emsp;知道什么是平台，我们看Java跨平台原理。 2.Java跨平台原理 &emsp;&emsp;Java的一大特色就是“write once, run anywhere”即“一次编译，到处运行”。就是说你不用专门为每个平台写一份代码，你写的Java程序在任何平台都能跑起来。&emsp;&emsp;它的实现原理是在系统层面上又增加了一层虚拟机（Java Virtual Machine，简称JVM），且为每个平台都定制了对应的虚拟机。然后Java程序是在虚拟机上跑的，因此平台无关。&emsp;&emsp;Java的运行流程是：程序员写了源代码（Source Code，.java后缀，跨平台），然后经过编译器编译成字节码（Byte Code，.class后缀，二进制文件，跨平台），字节码是所有虚拟机都能理解的中间文件。然后交给虚拟机（不跨平台，每个平台都有对应的虚拟机）去运行。&emsp;&emsp;所以对“write once, run anywhere”更准确的理解是，“一次编译，到处装虚拟机，所以到处运行”。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Hexo+Github+MWeb+七牛：个人博客搭建攻略（for mac）","date":"2015-09-10T05:42:08.000Z","path":"2015/09/10/hexo+github+MWeb+七牛/","text":"","tags":[]},{"title":"Node.js更新后npm无法正常运行的一种解决方法","date":"2015-09-09T10:34:03.000Z","path":"2015/09/09/Node-js更新后npm无法正常运行的一种解决方法/","text":"Node在更新后，会出现npm无法使用的情况，如下图： 可以通过回滚Node和npm版本的操作重置，操作如下1234$ sudo n 6.$ sudo npm install -g npm@3.10.0$ sudo npm install -g npm@next$ sudo n 7.","tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"Null不得不说的秘密","date":"2014-01-09T17:39:53.000Z","path":"2014/01/10/Null不得不说的秘密/","text":"1.大小写敏感首先，null是Java中的关键字，像public、static、final。它是大小写敏感的，你不能将null写成Null或NULL，编译器将不能识别它们然后报错。 12Object obj = NULL; // Not OkObject obj1 = null; //Ok 2.null是默认值就像每种原始类型都有默认值一样，如int默认值为0，boolean的默认值为false，null是任何引用类型的默认值，不严格的说是所有object类型的默认值。就像你创建了一个布尔类型的变量，它将false作为自己的默认值，Java中的任何引用变量都将null作为默认值。这对所有变量都是适用的，如成员变量、局部变量、实例变量、静态变量（但当你使用一个没有初始化的局部变量，编译器会警告你）。为了证明这个事实，你可以通过创建一个变量然后打印它的值来观察这个引用变量。 12345private static Object myObj;public static void main(String args[])&#123; System.out.println(&quot;What is value of myObjc : &quot; + myObj);&#125;What is value of myObjc : null 3.null是墙头草我们要澄清一些误解，null既不是对象也不是一种类型，它仅是一种特殊的值，你可以将其赋予任何引用类型，你也可以将null转化成任何类型。 1234567String str = null; // null can be assigned to StringInteger itr = null; // you can assign null to Integer alsoDouble dbl = null; // null can also be assigned to Double String myStr = (String) null; // null can be type cast to StringInteger myItr = (Integer) null; // it can also be type casted to IntegerDouble myDbl = (Double) null; // yes it&apos;s possible, no error 4.null也有它的底线null可以赋值给引用变量，你不能将null赋给基本类型变量，例如int、double、float、boolean。如果你那样做了，编译器将会报错，如下所示： 1234567int i = null; // type mismatch : cannot convert from null to intshort s = null; // type mismatch : cannot convert from null to shortbyte b = null: // type mismatch : cannot convert from null to bytedouble d = null; //type mismatch : cannot convert from null to double Integer itr = null; // this is okint j = itr; // this is also ok, but NullPointerException at runtime 5.null==null你可以使用==或者!=操作来比较null值，但是不能使用其他算法或者逻辑操作，例如小于或者大于。跟SQL不一样，在Java中null==null将返回true，如下所示： 1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String args[]) throws InterruptedException &#123; String abc = null; String cde = null; if(abc == cde)&#123; System.out.println(&quot;null == null is true in Java&quot;); &#125; if(null != null)&#123; System.out.println(&quot;null != null is false in Java&quot;); &#125; // classical null check if(abc == null)&#123; // do something &#125; // not ok, compile time error if(abc &gt; null)&#123; &#125; &#125;&#125;输出：null == null is true in Java 6.静态方法和非静态方法差别对待你可能知道不能调用非静态方法来使用一个值为null的引用类型变量。它将会抛出空指针异常，但是你可能不知道，你可以使用静态方法来使用一个值为null的引用类型变量。因为静态方法使用静态绑定，不会抛出空指针异常。下面是一个例子： 123456789101112131415161718public class Testing &#123; public static void main(String args[])&#123; Testing myObject = null; myObject.iAmStaticMethod(); myObject.iAmNonStaticMethod(); &#125; private static void iAmStaticMethod()&#123; System.out.println(&quot;I am static method, can be called by null reference&quot;); &#125; private void iAmNonStaticMethod()&#123; System.out.println(&quot;I am NON static method, don&apos;t date to call me by null&quot;); &#125; 输出：I am static method, can be called by null referenceException in thread &quot;main&quot; java.lang.NullPointerException at Testing.main(Testing.java:11)","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"override vs overload","date":"2014-01-09T17:39:53.000Z","path":"2014/01/10/override VS overload/","text":"1.重写（override） override是重写（覆盖）了一个方法，以实现不同的功能。一般是用于子类在继承父类时，重写（重新实现）父类中的方法。重写方法的参数列表必须完全与被重写的方法的相同,否则不能称其为重写而是重载. 重写方法的参数列表必须完全与被重写的方法的相同,否则不能称其为重写而是重载. 重写方法的访问修饰符一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private)。 重写的方法的返回值必须和被重写的方法的返回一致； 重写的方法所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其子类； 被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没s有对其进行重写。 静态方法不能被重写为非静态的方法（会编译出错）。 2.重载（overload） 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。重载是一个类中多态性的一种表现。 必须具有不同的参数列表； 可以有不同的返回类型，只要参数列表不同就可以了； 可以有不同的访问修饰符； 可以抛出不同的异常；","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java中的堆和栈的区别","date":"2013-09-14T14:41:36.000Z","path":"2013/09/14/Java中的堆和栈的区别/","text":"当一个人开始学习Java或者其他编程语言的时候，会接触到堆和栈，由于一开始没有明确清晰的说明解释，很多人会产生很多疑问，什么是堆，什么是栈，堆和栈有什么区别？更糟糕的是，Java中存在栈这样一个后进先出（Last In First Out）的顺序的数据结构，这就是java.util.Stack。这种情况下，不免让很多人更加费解前面的问题。事实上，堆和栈都是内存中的一部分，有着不同的作用，而且一个程序需要在这片区域上分配内存。众所周知，所有的Java程序都运行在JVM虚拟机内部，我们这里介绍的自然是JVM（虚拟）内存中的堆和栈。 1.一句话最主要的区别就是栈内存用来存储局部变量和方法调用。而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。 2.独有or共享栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。 3.异常错误如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。而如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。 4.空间大小栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。如果递归没有及时跳出，很可能发生StackOverFlowError问题。你可以通过-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小，-Xmx选项可以设置堆的最大值。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]}]