[{"title":"equals 和 == 的区别","date":"2017-09-14T15:41:34.000Z","path":"2017/09/14/equals-和-的区别/","text":"1.一句话== 操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。 equals操作表示的是两个变量是否是对同一个对象的引用，即堆中的内容是否相同。 更简单的说法：==比较的是地址，equals比较的是内容 2.举个栗子123456789101112public class EqualsTest &#123; public static void main(String[] args)&#123; String s1 = &quot;Test&quot;; String s2 = &quot;Test&quot;; System.out.println(&quot;s1 == s2 : &quot; + (s1 == s2)); System.out.println(&quot;s1.equals(s2): &quot; + s1.equals(s2)); &#125;&#125;输出结果：s1 == s2 : trues1.equals(s2): true 接下来，做些改动：将s2通过new的方式来创建 123456789101112public class EqualsTest &#123; public static void main(String[] args)&#123; String s1 = &quot;Test&quot;; String s2 = new String(&quot;Test&quot;); System.out.println(&quot;s1 == s2 : &quot; + (s1 == s2)); System.out.println(&quot;s1.equals(s2): &quot; + s1.equals(s2)); &#125;&#125;输出结果：s1 == s2 : falses1.equals(s2): true 分析： 对于第一种情况，创建s2时，程序会在缓冲池中寻找到具有相同值的s1，因此s2和s1共同引用对象”Test”。也就是说s1和s2的引用地址相同，那么自然引用对象也是相同的咯。所以两者都为true。 对于第二种情况，我们通过new方式创建了s2，相当于告诉程序“我要个新的，不要旧的”。因此，程序会重新创建一个”Test”对象在内存中，虽然它们的值相同，但它们的位置是不同的。因此，它们的引用地址自然是不同的，==操作自然为false，equals为true，因为它们的内容还是相同的。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Idea for mac  MyBatis-plugin破解","date":"2016-01-09T17:39:53.000Z","path":"2016/01/10/Idea-for-mac-MyBatis-plugin破解/","text":"1.下载MyBatis-plugin插件Preferences–&gt;Plugins–&gt;搜索Mybatis-Plugin–&gt;Install–&gt;关闭Idea 2.找到Idea中MyBatis-plugin的安装路径1cd ~/Library/Application Support/IntelliJIdea201X.X/mybatis_plus/lib 3.克隆项目1git clone https://github.com/myoss/profile.git 4.将profile里面的com拷贝到 lib下1cp -R ./profile/idea/plugin/MybatisPulgin/v2.7~2.91/com ~/Library/Application Support/IntelliJIdea201x.x/mybatis_plus/lib 5.用com文件夹中的信息更新mybatis_plus.jar1jar uvf mybatis_plus.jar com 6.重启idea","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"Hexo+Github+MWeb+七牛：个人博客搭建攻略（for mac）","date":"2015-09-10T05:42:08.000Z","path":"2015/09/10/hexo+github+MWeb+七牛/","text":"","tags":[]},{"title":"Node.js更新后npm无法正常运行的一种解决方法","date":"2015-09-09T10:34:03.000Z","path":"2015/09/09/Node-js更新后npm无法正常运行的一种解决方法/","text":"Node在更新后，会出现npm无法使用的情况，如下图： 可以通过回滚Node和npm版本的操作重置，操作如下1234$ sudo n 6.$ sudo npm install -g npm@3.10.0$ sudo npm install -g npm@next$ sudo n 7.","tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"Null不得不说的秘密","date":"2014-01-09T17:39:53.000Z","path":"2014/01/10/Null不得不说的秘密/","text":"1.大小写敏感首先，null是Java中的关键字，像public、static、final。它是大小写敏感的，你不能将null写成Null或NULL，编译器将不能识别它们然后报错。 12Object obj = NULL; // Not OkObject obj1 = null; //Ok 2.null是默认值就像每种原始类型都有默认值一样，如int默认值为0，boolean的默认值为false，null是任何引用类型的默认值，不严格的说是所有object类型的默认值。就像你创建了一个布尔类型的变量，它将false作为自己的默认值，Java中的任何引用变量都将null作为默认值。这对所有变量都是适用的，如成员变量、局部变量、实例变量、静态变量（但当你使用一个没有初始化的局部变量，编译器会警告你）。为了证明这个事实，你可以通过创建一个变量然后打印它的值来观察这个引用变量。 12345private static Object myObj;public static void main(String args[])&#123; System.out.println(&quot;What is value of myObjc : &quot; + myObj);&#125;What is value of myObjc : null 3.null是墙头草我们要澄清一些误解，null既不是对象也不是一种类型，它仅是一种特殊的值，你可以将其赋予任何引用类型，你也可以将null转化成任何类型。 1234567String str = null; // null can be assigned to StringInteger itr = null; // you can assign null to Integer alsoDouble dbl = null; // null can also be assigned to Double String myStr = (String) null; // null can be type cast to StringInteger myItr = (Integer) null; // it can also be type casted to IntegerDouble myDbl = (Double) null; // yes it&apos;s possible, no error 4.null也有它的底线null可以赋值给引用变量，你不能将null赋给基本类型变量，例如int、double、float、boolean。如果你那样做了，编译器将会报错，如下所示： 1234567int i = null; // type mismatch : cannot convert from null to intshort s = null; // type mismatch : cannot convert from null to shortbyte b = null: // type mismatch : cannot convert from null to bytedouble d = null; //type mismatch : cannot convert from null to double Integer itr = null; // this is okint j = itr; // this is also ok, but NullPointerException at runtime 5.null==null你可以使用==或者!=操作来比较null值，但是不能使用其他算法或者逻辑操作，例如小于或者大于。跟SQL不一样，在Java中null==null将返回true，如下所示： 1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String args[]) throws InterruptedException &#123; String abc = null; String cde = null; if(abc == cde)&#123; System.out.println(&quot;null == null is true in Java&quot;); &#125; if(null != null)&#123; System.out.println(&quot;null != null is false in Java&quot;); &#125; // classical null check if(abc == null)&#123; // do something &#125; // not ok, compile time error if(abc &gt; null)&#123; &#125; &#125;&#125;输出：null == null is true in Java 6.静态方法和非静态方法差别对待你可能知道不能调用非静态方法来使用一个值为null的引用类型变量。它将会抛出空指针异常，但是你可能不知道，你可以使用静态方法来使用一个值为null的引用类型变量。因为静态方法使用静态绑定，不会抛出空指针异常。下面是一个例子： 123456789101112131415161718public class Testing &#123; public static void main(String args[])&#123; Testing myObject = null; myObject.iAmStaticMethod(); myObject.iAmNonStaticMethod(); &#125; private static void iAmStaticMethod()&#123; System.out.println(&quot;I am static method, can be called by null reference&quot;); &#125; private void iAmNonStaticMethod()&#123; System.out.println(&quot;I am NON static method, don&apos;t date to call me by null&quot;); &#125; 输出：I am static method, can be called by null referenceException in thread &quot;main&quot; java.lang.NullPointerException at Testing.main(Testing.java:11)","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"override vs overload","date":"2014-01-09T17:39:53.000Z","path":"2014/01/10/override VS overload/","text":"1.重写（override） override是重写（覆盖）了一个方法，以实现不同的功能。一般是用于子类在继承父类时，重写（重新实现）父类中的方法。重写方法的参数列表必须完全与被重写的方法的相同,否则不能称其为重写而是重载. 重写方法的参数列表必须完全与被重写的方法的相同,否则不能称其为重写而是重载. 重写方法的访问修饰符一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private)。 重写的方法的返回值必须和被重写的方法的返回一致； 重写的方法所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其子类； 被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没s有对其进行重写。 静态方法不能被重写为非静态的方法（会编译出错）。 2.重载（overload） 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。重载是一个类中多态性的一种表现。 必须具有不同的参数列表； 可以有不同的返回类型，只要参数列表不同就可以了； 可以有不同的访问修饰符； 可以抛出不同的异常；","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java中的堆和栈的区别","date":"2013-09-14T14:41:36.000Z","path":"2013/09/14/Java中的堆和栈的区别/","text":"当一个人开始学习Java或者其他编程语言的时候，会接触到堆和栈，由于一开始没有明确清晰的说明解释，很多人会产生很多疑问，什么是堆，什么是栈，堆和栈有什么区别？更糟糕的是，Java中存在栈这样一个后进先出（Last In First Out）的顺序的数据结构，这就是java.util.Stack。这种情况下，不免让很多人更加费解前面的问题。事实上，堆和栈都是内存中的一部分，有着不同的作用，而且一个程序需要在这片区域上分配内存。众所周知，所有的Java程序都运行在JVM虚拟机内部，我们这里介绍的自然是JVM（虚拟）内存中的堆和栈。 1.一句话最主要的区别就是栈内存用来存储局部变量和方法调用。而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。 2.独有or共享栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。而堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。 3.异常错误如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError。而如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError。 4.空间大小栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。如果递归没有及时跳出，很可能发生StackOverFlowError问题。你可以通过-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小，-Xmx选项可以设置堆的最大值。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]}]